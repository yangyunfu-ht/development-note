import{_ as i,o as a,c as n,ag as l}from"./chunks/framework.CbQjVMS6.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"javascript/components/variableLifting.md","filePath":"javascript/components/variableLifting.md"}'),t={name:"javascript/components/variableLifting.md"};function e(p,s,h,o,k,r){return a(),n("div",null,[...s[0]||(s[0]=[l(`<h2 id="变量提升-hoisting" tabindex="-1">变量提升 (Hoisting) <a class="header-anchor" href="#变量提升-hoisting" aria-label="Permalink to &quot;变量提升 (Hoisting)&quot;">​</a></h2><p>变量提升（Hoisting）是 JavaScript 引擎中的一种机制，它会将变量声明和函数声明移动到当前作用域的顶部。</p><p>这意味着你可以在声明变量或函数之前使用它们。</p><h3 id="_1-var-的提升" tabindex="-1">1. var 的提升 <a class="header-anchor" href="#_1-var-的提升" aria-label="Permalink to &quot;1. var 的提升&quot;">​</a></h3><p>使用 <code>var</code> 声明的变量会被提升，但<strong>初始化不会被提升</strong>。在声明语句之前访问该变量，其值为 <code>undefined</code>。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(foo); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// undefined</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(foo); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;Hello&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 实际执行过程相当于：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// var foo;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// console.log(foo);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// foo = &#39;Hello&#39;;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// console.log(foo);</span></span></code></pre></div><h3 id="_2-函数声明的提升" tabindex="-1">2. 函数声明的提升 <a class="header-anchor" href="#_2-函数声明的提升" aria-label="Permalink to &quot;2. 函数声明的提升&quot;">​</a></h3><p><strong>函数声明</strong>会被完整地提升到作用域顶部。你可以在声明函数之前调用它。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sayHi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;Hi!&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sayHi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hi!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_3-函数表达式与提升" tabindex="-1">3. 函数表达式与提升 <a class="header-anchor" href="#_3-函数表达式与提升" aria-label="Permalink to &quot;3. 函数表达式与提升&quot;">​</a></h3><p><strong>函数表达式</strong>（Function Expression）通常是赋值给一个变量。它们的行为遵循变量提升的规则。</p><p>如果使用 <code>var</code> 声明函数表达式，变量名被提升，但函数体不提升。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sayHello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// TypeError: sayHello is not a function</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sayHello</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>如果使用 <code>let</code> 或 <code>const</code> 声明函数表达式，同样受暂时性死区（TDZ）限制，无法在声明前调用。</p><h3 id="_4-let-和-const-的提升" tabindex="-1">4. let 和 const 的提升 <a class="header-anchor" href="#_4-let-和-const-的提升" aria-label="Permalink to &quot;4. let 和 const 的提升&quot;">​</a></h3><p><code>let</code> 和 <code>const</code> 声明的变量<strong>也会被提升</strong>，但它们不会被初始化。</p><p>在声明语句之前的区域被称为<strong>暂时性死区（Temporal Dead Zone, TDZ）</strong>。在 TDZ 中访问这些变量会抛出 <code>ReferenceError</code>。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bar); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ReferenceError: Cannot access &#39;bar&#39; before initialization</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;World&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="_5-优先级规则" tabindex="-1">5. 优先级规则 <a class="header-anchor" href="#_5-优先级规则" aria-label="Permalink to &quot;5. 优先级规则&quot;">​</a></h3><p>当函数声明和变量声明同名时，<strong>函数声明的优先级高于变量声明</strong>。函数声明会覆盖同名的变量声明（但不会覆盖变量赋值）。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [Function: a]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span></code></pre></div><p><strong>解析过程</strong>：</p><ol><li>引擎首先处理函数声明 <code>function a() {}</code>，将其提升。</li><li>然后处理变量声明 <code>var a</code>，发现 <code>a</code> 已经存在（是函数），忽略变量声明。</li><li>代码执行阶段： <ul><li><code>console.log(a)</code>：输出函数 <code>a</code>。</li><li><code>a = 1</code>：赋值操作，将 <code>a</code> 修改为 <code>1</code>。</li><li><code>console.log(a)</code>：输出 <code>1</code>。</li></ul></li></ol>`,23)])])}const g=i(t,[["render",e]]);export{c as __pageData,g as default};
