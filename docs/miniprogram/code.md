# 小程序高频面试题汇总

## 1. 小程序的架构原理是怎样的？（双线程模型）

小程序基于**双线程模型**运行：

- **渲染层 (View Layer)**: 使用 WebView 渲染 WXML 和 WXSS。如果有多个页面，会存在多个 WebView 线程。
- **逻辑层 (App Service)**: 使用 JsCore 运行 JavaScript 代码。

**通信机制**：
两个线程之间互不直接通信，而是通过 **Native (微信客户端)** 进行中转。

1. 逻辑层发送数据 -> Native -> 渲染层。
2. 渲染层触发事件 -> Native -> 逻辑层。

**为什么这样设计？**
为了**管控**和**安全**。阻止开发者直接操作 DOM（避免页面跳转、动态执行脚本等不可控行为），保证用户体验和数据安全。

## 2. 小程序与普通 H5 的区别？

| 特性         | 小程序                                   | H5 (Web 页面)                  |
| :----------- | :--------------------------------------- | :----------------------------- |
| **运行环境** | 微信客户端 (JsCore + WebView)            | 浏览器                         |
| **开发语言** | WXML, WXSS, JS, JSON                     | HTML, CSS, JS                  |
| **DOM 操作** | **禁止直接操作 DOM**                     | 可以随意操作 DOM               |
| **系统权限** | 能调用微信原生能力 (扫码、定位、支付)    | 权限受限，需通过 JSSDK         |
| **加载速度** | 首次加载慢 (需下载包)，后续快 (本地缓存) | 取决于网络，每次可能需请求资源 |
| **发布**     | 需经过微信审核                           | 随时发布，实时更新             |

## 3. 小程序的生命周期有哪些？

主要分为**应用级别**、**页面级别**和**组件级别**。

### 应用生命周期 (App)

- `onLaunch`: 小程序初始化完成时触发（全局只触发一次）。
- `onShow`: 小程序启动，或从后台进入前台显示时触发。
- `onHide`: 小程序从前台进入后台时触发。

### 页面生命周期 (Page)

- `onLoad`: 页面加载时触发（一个页面只调用一次）。
- `onShow`: 页面显示/切入前台时触发。
- `onReady`: 页面初次渲染完成时触发。
- `onHide`: 页面隐藏/切入后台时触发。
- `onUnload`: 页面卸载时触发。

### 组件生命周期 (Component)

- `created`: 组件实例刚刚被创建时执行。
- `attached`: 组件实例进入页面节点树时执行。
- `ready`: 组件在视图层布局完成后执行。
- `detached`: 组件实例被从页面节点树移除时执行。

## 4. 简述小程序的登录流程

1. **小程序端**调用 `wx.login()` 获取临时登录凭证 **code**。
2. **小程序端**将 code 发送给**开发者服务器**。
3. **开发者服务器**将 code + appid + appsecret 发送给**微信服务器**。
4. **微信服务器**验证成功后，返回 **session_key** 和 **openid** 给开发者服务器。
5. **开发者服务器**生成自定义登录态 (token)，关联 openid，并返回给**小程序端**。
6. **小程序端**将 token 存入 `wx.setStorageSync`，后续请求携带 token。

## 5. 什么是 OpenID 和 UnionID？

- **OpenID**: 用户在**当前小程序**中的唯一标识。同一个用户在不同的小程序中，OpenID 是不同的。
- **UnionID**: 用户在**微信开放平台账号**下的唯一标识。如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），只要这些帐号绑定了同一个微信开放平台帐号，用户的 UnionID 是唯一的。

**场景**：如果需要打通小程序、公众号、App 之间的用户账号，需要使用 UnionID。

## 6. bindtap 和 catchtap 的区别？

- **bindtap**: 冒泡事件。事件触发后，会向父节点传递。
- **catchtap**: 非冒泡事件。事件触发后，**阻止**事件向父节点传递。

## 7. wxss 和 css 的区别？

1. **尺寸单位**: WXSS 新增了 **rpx** (responsive pixel)，可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。
2. **样式引入**: WXSS 使用 `@import` 导入外联样式。
3. **选择器**: WXSS 仅支持部分 CSS 选择器（class, id, element, ::after, ::before）。
4. **没有 DOM**: 无法使用层级过深的选择器，也无法动态操作样式（通常通过 class 切换）。

## 8. setData 的原理及性能优化

**原理**：
`setData` 是将数据从逻辑层发送到视图层（异步），同时改变对应的 `this.data` 的值（同步）。
数据传输需要经过 Native 层，涉及序列化和反序列化，通过 `evaluateJavascript` 执行。

**性能优化 (常见坑)**：

1. **避免频繁调用**: 不要在一个循环中频繁调用 `setData`，应合并数据后一次性调用。
2. **避免数据量过大**: 单次 `setData` 的数据不应超过 1024KB。不要把页面无关的数据（如巨大的图片 Base64）放在 data 中。
3. **避免后台态页面进行 setData**: 页面切入后台后，应停止动画和数据更新。

## 9. 小程序页面间有哪些通信方式？

1. **URL 参数**: `wx.navigateTo({ url: 'page?id=1' })`，在 `onLoad` 中接收。
2. **全局变量**: 修改 `App.globalData`。
3. **本地缓存**: `wx.setStorage` / `wx.getStorage`。
4. **EventChannel**: 页面跳转时建立的事件通道（`wx.navigateTo` 的 `success` 回调中）。
5. **获取页面栈**: `getCurrentPages()` 获取前一个页面的实例，直接调用其方法或修改数据（不推荐，耦合度高）。

## 10. 什么是分包加载？为什么要分包？

**概念**：将小程序代码划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。

**原因**：

1. **突破体积限制**: 微信限制单个主包/分包大小不能超过 2MB，整个小程序所有分包大小不超过 20MB。
2. **加快启动速度**: 首次启动时只加载主包，减少下载时间，提升用户体验。

**类型**：

- **主包**: 包含启动页面和公共资源。
- **普通分包**: 进入分包页面时才加载。
- **独立分包**: 不依赖主包即可运行。

## 11. 小程序怎么实现下拉刷新？

1. **配置**: 在 `app.json` 或页面 `json` 中配置 `"enablePullDownRefresh": true`。
2. **监听**: 在页面 JS 中监听 `onPullDownRefresh` 生命周期方法。
3. **停止**: 数据请求完成后，务必调用 `wx.stopPullDownRefresh()` 停止刷新动画。
