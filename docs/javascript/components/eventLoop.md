## 事件循环 (Event Loop)

JavaScript 是一门**单线程**的非阻塞脚本语言。为了协调事件、用户交互、脚本、渲染、网络等，JavaScript 必须使用事件循环（Event Loop）机制来处理异步任务。

### 1. 核心概念

- **执行栈 (Call Stack)**：
  JavaScript 引擎维护一个执行栈，用于追踪函数调用。这是一个同步过程，遵循**后进先出 (LIFO)** 原则。所有同步代码都在这里执行。

- **任务队列 (Task Queue)**：
  当遇到异步操作（如 `setTimeout`, `fetch`）时，回调函数会在异步操作完成后被放入任务队列中等待执行。

### 2. 宏任务与微任务

在事件循环中，异步任务被分为两类，它们的执行优先级不同。

| 任务类型               | 描述                                | 常见 API                                                                                            |
| :--------------------- | :---------------------------------- | :-------------------------------------------------------------------------------------------------- |
| **宏任务 (MacroTask)** | 由宿主环境（浏览器/Node）发起的任务 | `script`(整体代码), `setTimeout`, `setInterval`, `setImmediate`(Node), `requestAnimationFrame`, I/O |
| **微任务 (MicroTask)** | 由 JavaScript 引擎发起的任务        | `Promise.then/catch/finally`, `process.nextTick`(Node), `MutationObserver`                          |

### 3. 循环流程 (The Loop)

事件循环的每一次迭代称为一个 **Tick**，其基本流程如下：

1.  **执行栈**：执行当前执行栈中的所有同步代码。
2.  **微任务队列**：当执行栈为空时，**清空**当前的微任务队列。
    - 如果在执行微任务期间产生了新的微任务，会继续添加到队列末尾并在当前周期执行。
3.  **UI 渲染**：(浏览器环境) 如果需要，浏览器进行 UI 更新。
4.  **宏任务队列**：从宏任务队列中取出**一个**任务执行。
5.  **重复**：回到步骤 1。

> **核心口诀**：同步优先 -> 微任务清空 -> 渲染 -> 宏任务一个 -> 循环

### 4. 代码实战解析

#### 示例 1：基础顺序

```javascript
console.log("1"); // 同步

setTimeout(function () {
  console.log("2"); // 宏任务
}, 0);

Promise.resolve().then(function () {
  console.log("3"); // 微任务
});

console.log("4"); // 同步
```

**输出结果**：`1` -> `4` -> `3` -> `2`

**解析**：

1. 同步代码 `1`, `4` 先执行。
2. 同步执行完，检查微任务，执行 `3`。
3. 微任务清空，执行宏任务 `2`。

---

#### 示例 2：综合面试题

```javascript
console.log("1");

setTimeout(() => {
  console.log("2");
  Promise.resolve().then(() => {
    console.log("3");
  });
}, 0);

new Promise((resolve) => {
  console.log("4"); // Promise 构造函数是同步的
  resolve();
}).then(() => {
  console.log("5");
});

console.log("6");
```

**输出结果**：`1` -> `4` -> `6` -> `5` -> `2` -> `3`

**深度解析**：

1.  **第一轮 (同步 + 微任务)**
    - 打印 `1`。
    - `setTimeout` 注册宏任务 **[Macro1]**。
    - `new Promise` 同步执行打印 `4`。
    - `.then` 注册微任务 **[Micro1]** (打印 5)。
    - 打印 `6`。
    - **清空微任务**：执行 **[Micro1]** -> 打印 `5`。

2.  **第二轮 (宏任务)**
    - 取出 **[Macro1]** 执行 -> 打印 `2`。
    - 遇到 `Promise.then`，注册微任务 **[Micro2]** (打印 3)。
    - **宏任务执行完，再次清空微任务**。
    - 执行 **[Micro2]** -> 打印 `3`。
